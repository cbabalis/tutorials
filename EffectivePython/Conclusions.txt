Lists:

Don't be verbose
    - no 0 for the start index
    - no length for the end index

Slicing is forgiving of start or end indexes.

Having two lists, assigning to a list slice will replace that range in the
original sequence (even if lengths are different).

#6
Use positive stride values in slices WITHOUT start/end indexes.
Avoid negative stride values.

Avoid using start, end and stride together in a slingle slice.

#7
Prefer list comprehensions than "map" and "filter" built-in functions

Dictionaries also support comprehension expressions.

#9
List comprehensions may cause probs for large inputs (memory)

Generator expressions avoid memory issues

Generator expressions can be composed by passing the iterator from one
generator expression intothe for subexpression of another

Generator expressions: very quick when chained together.

#10
Prefer enumerate over range

If needed, supply a second parameter to enumerate to specify the number from which to
begin counting

#11
The "zip" built-in function can be used to iterate over multiple iterators IN
PARALLEL.

Python3: zip is a generator which produces tuples
PYthon2: zip returns the full result as list of tuples

zip truncates its output SILENTLY if iterators have different lengths

#12
Python has special syntax with else blocks to immediately follow for and while
loop interior blocks.

Else block runs only if the loop body did not encounter a break statement.

Avoid using else blocks after loops.

#14
Raise exceptions to indicate special situations instead of returning None.

Expect the calling code to handle exceptions properly when they 're documented.

#15
1. Closure functions can refer to variables from any of the scopes in which
they where defined.
2. By default closures can't affect enclosing scopes by assigning variables.
3. In Python 3. use the nonlocal statement to indicate when a closure can modify
a variable in its enclosing scopes.
4. In Python 2, use a mutable value (single-item list). Equivalent to nonlocal.
(i.e. found = [False]
        found[0] = True)
5. AVOID using nonlocal statements for anything beyond simple functions.

#16
1. Using generators can be clearer
2. The iterator returned by a gnerator produces the set of values passed to
yield expressions within the generator function's body.
3. Generators can produce a sequence of outputs for arbitrarily large inputs
because their working memory doesn't include all inputs and outputs.

#17
1. Be careful of functions that iterate over input arguments multiple times.
2. You can easily define your own iterable container type by implementing the
__iter__ method as a generator.
3. You can detect that a value is an iterator instead of a container if
    calling iter on it twice produces the same result, which can then be
    progressed with the next built-in function.

#18
1. Functions can accept a variable number of positional arguments by using
*args in the def statement.
2. You can use the items from a sequence as the positional arguments for a
function with the * operator.
3. Using the * operator with a generator may cause your program to run out of
memory and crash.

#19
1. Function arguments can be specified by position or by keyword.
2. Keywords make it clear what the purpose of each argument is when it would be
confusing with only positional arguments.
3. Keyword argumetns with default values make it easy to add new behaviors to a
function, especially when the function has existing callers.
4. Optional keyword arguments should always be passed by keyword instead of by
position.

#20
1. Default arguments are only evaluated once: during function definition at
module load time. Unpredicted behavior for dynamic values ({}, []).
2. Use None as the default value for keyword arguments that have a dynamic
value. Document the actual default behavior in the function's docstring.

#21
1. Keyword arguments make the intention of a function call more clear.
2. Use keyword-only arguments to force callres to supply keyword arguments for
potentially confusing functions, especially those that accept multiple Boolean
flags.
3. Python 3 supports explicit syntax for keyword-only arguments in functions.
4. Python 2 can emulate keyword-only arguments for functions by using **kwargs
and manually raising TypeError exceptions.

#22
1. Avoid making dictionaries with values that are other dictionaries or long
tuples.
2. Use namedtuple for lightweight, immutable data containers BEFORE full class
3. Use multiple helper classes when internal state dictionaries get
complicated.

#23
1. Instead of defining and instantiating classes, functions are often all you
need for simple interfaces between components in python.
2. References to functions and methods in Python are first class, meaning they
can be used in expressions like any other type.
3. The __call__ special method enables instances of a class to be called like
plain Python functions.
4. When you need a function to maintian state, consider defining a class that
provides the __call__ method instead of defining a stateful closure.

#24
1. Python only supports a single constructor per class, the __init-_ method.
2. Use @classmethod to define alternative constructors for your classes.
3. Use class method polymorphism to provide generic ways to build and connect
concrete subclasses.

#25
1. Python's standard method resolution order (MRO) solves the problems of
superclass initialization order and diamond inheritance.
2. Always use the super built-in function to initialize parent classes.

#26
1. Avoing multiple inheritance if mix-in classes can achieve the same outcome.
2. Usggable behaviors at the instance level to provide per-class customization
when mix-in classes require it.
3. Compose mix-ins to create complex functionality from simple behaviors.

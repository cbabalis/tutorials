Lists:

Don't be verbose
    - no 0 for the start index
    - no length for the end index

Slicing is forgiving of start or end indexes.

Having two lists, assigning to a list slice will replace that range in the
original sequence (even if lengths are different).

#6
Use positive stride values in slices WITHOUT start/end indexes.
Avoid negative stride values.

Avoid using start, end and stride together in a slingle slice.

#7
Prefer list comprehensions than "map" and "filter" built-in functions

Dictionaries also support comprehension expressions.

#9
List comprehensions may cause probs for large inputs (memory)

Generator expressions avoid memory issues

Generator expressions can be composed by passing the iterator from one
generator expression intothe for subexpression of another

Generator expressions: very quick when chained together.

#10
Prefer enumerate over range

If needed, supply a second parameter to enumerate to specify the number from which to
begin counting

#11
The "zip" built-in function can be used to iterate over multiple iterators IN
PARALLEL.

Python3: zip is a generator which produces tuples
PYthon2: zip returns the full result as list of tuples

zip truncates its output SILENTLY if iterators have different lengths

#12
Python has special syntax with else blocks to immediately follow for and while
loop interior blocks.

Else block runs only if the loop body did not encounter a break statement.

Avoid using else blocks after loops.

#14
Raise exceptions to indicate special situations instead of returning None.

Expect the calling code to handle exceptions properly when they 're documented.

#15
1. Closure functions can refer to variables from any of the scopes in which
they where defined.
2. By default closures can't affect enclosing scopes by assigning variables.
3. In Python 3. use the nonlocal statement to indicate when a closure can modify
a variable in its enclosing scopes.
4. In Python 2, use a mutable value (single-item list). Equivalent to nonlocal.
(i.e. found = [False]
        found[0] = True)
5. AVOID using nonlocal statements for anything beyond simple functions.

#16
1. Using generators can be clearer
2. The iterator returned by a gnerator produces the set of values passed to
yield expressions within the generator function's body.
3. Generators can produce a sequence of outputs for arbitrarily large inputs
because their working memory doesn't include all inputs and outputs.

#17

